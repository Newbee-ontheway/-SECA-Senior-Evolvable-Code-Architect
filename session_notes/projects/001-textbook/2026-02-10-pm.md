# Session Note: 2026-02-10 PM

# 软件工程经验笔记

> 本笔记从 V3.5 项目的实际问题中提炼出**可迁移的工程规则**。
> 每条规则适用于任何软件项目，不限于本项目。

---

## 规则 1：操作手册和参考资料必须分开存放

**工程概念**: Separation of Concerns（关注点分离）

**通俗解释**:
想象你在厨房。菜谱（怎么做）和食材清单（用什么）是两种东西。
如果你把菜谱和食材清单混在一个抽屉里，找起来会很混乱。

**工程规则**:
- **操作手册**（How to do）= 执行时参照的规则、流程、策略
- **参考资料**（What to use）= 原始知识、数据、素材

两者必须放在不同的位置，职责清晰：

```
✅ 正确                          ❌ 错误
rules/  → 操作手册               混在一起/
data/   → 参考资料                 ├── 菜谱A.md
                                   ├── 食材清单.md
                                   └── 菜谱B.md
```

**在本项目中**: `agent_rules/skills/`（操作手册）和 `library/`（参考资料）各有各的用途。
但因为没有严格区分，导致 15 个文件被复制到了两个地方。

**你以后做任何项目时**:
当你创建一个新文件，先问自己：这是**指导 AI/人怎么做的**，还是**提供原始内容的**？
答案决定了它应该放在哪个目录。

---

## 规则 2：不要设计依赖于你没有的数据的功能

**工程概念**: Data-Driven Design 的前提条件

**通俗解释**:
如果你设计一个"按价格排序"的功能，但你的商品数据库里**没有价格字段** —— 这个功能就是空转的。它看起来存在，但实际上只是在猜。

**工程规则**:
设计功能之前，检查**数据链路**是否完整：

```
功能需求 → 需要什么数据 → 数据在哪里 → 数据可靠吗？
    ↓           ↓              ↓             ↓
  "排序"      "价格"        "数据库"       ✅ / ❌
```

如果数据链路断了，你有三个选择：

| 选择 | 做法 | 适用场景 |
|------|------|----------|
| A. 先建数据 | 收集真实数据，再上线功能 | 数据可获取 |
| B. 改设计 | 不依赖缺失数据，改用可用信息 | 数据暂时无法获取 |
| C. 诚实标注 | 功能可用，但标明"基于推测" | 临时方案 |

**在本项目中**: P0/P1/P2 声称"按高考频率分级"，但没有频率数据。解决方案是 B+A 并行（改为"教学重要性"，同时为未来建频率数据库留接口）。

**你以后做任何项目时**:
当你规划一个功能，画一张数据链路图。如果某个环节标了❌，这个功能要么推迟，要么改设计。**不要假装数据存在。**

---

## 规则 3：系统设计必须预留多条路径，而非只为一种情况硬编码

**工程概念**: Open-Closed Principle（开闭原则）— 对扩展开放，对修改封闭

**通俗解释**:
如果你开了一家快递站，只设计了"寄包裹"的流程。有一天客户来取件，你发现整个系统没有"取件"的路径 —— 你不得不重写整个流程。

**工程规则**:

```
❌ 硬编码（只适配一种输入）
function process(input):
    readGrammarFile()       ← 假设输入一定是语法
    classifyByFrequency()   ← 假设一定有频率数据
    generateUnit()

✅ 路由模式（根据输入类型分发）
function process(input):
    type = detectType(input)   ← 先判断输入是什么
    switch(type):
        "grammar"  → grammarPath()
        "vocab"    → vocabPath()
        "reading"  → readingPath()
        _          → askUser()   ← 不确定就问
```

**判断你的系统是否有这个问题**:
- 问自己："如果用户给了一个**完全不同类型**的输入，系统能处理吗？"
- 如果答案是"不能，要改代码" → 你的系统是硬编码的
- 如果答案是"能，加一条路由就行" → 你的系统是开放的

**在本项目中**: Architect 只有"语法分析"一条路径。给它 15 个单词，它不知道怎么处理。

**你以后做任何项目时**:
设计任何"处理用户输入"的模块时，**至少考虑 3 种不同类型的输入**。如果你只为一种输入写了逻辑，未来一定会重写。

---

## 规则 4：单一文件，单一位置

**工程概念**: Single Source of Truth（单一真相源）

**通俗解释**:
你有一份合同，复印了两份分别放在办公室和家里。有一天你修改了办公室的版本，但忘了改家里那份。现在你有两份不同的"合同"，哪份是对的？

**工程规则**:
- 每份文件/数据/配置只允许存在于**一个位置**
- 其他地方如果需要引用，使用**链接/指针**，不要复制内容
- 需要修改时，只改一个地方，所有引用自动生效

```
✅ 正确                    ❌ 错误
config.json (唯一)         config.json (版本A)
  ↗ 链接引用                config_backup.json (版本B)
  ↗ 链接引用                config_copy.json (版本C)
```

**你以后做任何项目时**:
如果你发现自己在**复制粘贴**一个文件到另一个目录 → **停下来**。问自己：我应该链接还是复制？99% 的情况答案是链接。

---

## 规则 5：先解决影响工作效率的系统性问题

**工程概念**: Technical Debt Prioritization（技术债优先级）

**通俗解释**:
你的工具箱锁坏了，每次拿工具要花 5 分钟撬开。你可以选择：
A) 忍着，继续干活（每次浪费 5 分钟）
B) 先花 10 分钟修锁，然后每次 0 成本

**工程规则**:
如果一个问题**每次操作都会出现**，它的优先级比任何功能开发都高。

```
优先修的问题：
✅ 每次编辑都触发 200 条警告（lint 噪音）
✅ 每次部署都要手动改 3 个配置文件
✅ 测试跑一次要 30 分钟

可以后修的问题：
⬚ 某个页面的按钮颜色不太对
⬚ 代码里有个函数命名不规范
```

**判断公式**: `影响次数 × 每次浪费时间 = 总成本`

如果总成本 > 修复成本 → **立刻修**。

---

## 本次修改清单

| 文件 | 改动 |
|------|------|
| `architect_v3.5.md` | 重写：多类型路由 + 交互式输入 + 教学重要性分级 |
| `V3.5_Golden_Rulebook.md` | Architect 段落对齐新设计 |
| `core_knowledge_base.md` | workspace→交互式，加 exam_frequency 引用 |
| `library/knowledge/exam_frequency/` | 新建占位目录 |
| `library/standards/` | 删除 15 个重复文件 |
| `.markdownlint.json` | 新建，禁用 9 个噪音规则 |
| `.agent/workflows/distributed_execution.md` | 新建分步执行协议 |
