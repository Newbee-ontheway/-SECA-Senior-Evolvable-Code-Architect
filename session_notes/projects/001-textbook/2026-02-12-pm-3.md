# Session Note: 2026-02-12 Afternoon (Part 3) ⭐ 重要

# AI Review AI Code 的难点与优化路径

> 来源: 与 Gemini 的对话 + 自身分析
> 证据强度: `[实践经验 + 工程推理, 未独立实验验证]`

---

## 规则 26：同源盲区 — AI 无法有效 Review 自己的代码

**通俗解释**: 写出 Bug 的模型和 Review Bug 的模型是同一个（或同系列），它无法跳出自己的逻辑闭环。就像校对自己写的文章很难发现错别字。

**四个难点**:

| 难点 | 原因 | 严重程度 |
|------|------|---------|
| 同源盲区 | 同一模型有同样的知识盲区 | ⭐⭐⭐⭐⭐ |
| 上下文限制 | 只能看到当前文件，不了解全局架构 | ⭐⭐⭐⭐ |
| 幻觉误报 | 指出不存在的 Bug，浪费人的时间 | ⭐⭐⭐ |
| 讨好倾向 | 倾向于说"没问题"而非挑刺 | ⭐⭐⭐ |

**Gemini 遗漏的两点**:
1. 自我修正的递减效应 — 如果第一次错是认知层面的，重试 10 次也一样错
2. Review ≠ 找 Bug — 设计合理性、命名品味等判断比找 Bug 更难

---

## 规则 27：验证层悖论 — 加防线本身可能成为新的故障源

**核心矛盾**: 为了防 AI 出错而加的验证环节，如果也是 AI 做的，那本身就不可靠。

**推论**: 验证层**必须是确定性的**（编译器、lint、测试），不能是另一个 AI。

**与已有原则的关系**:
- `PRACTICE-04` Layer 3 已经说了"事后验证必须用确定性工具"
- `PRACTICE-07` 确定性优先，验证环节更应如此
- `ARCH-06` 每多一个不确定环节，系统可靠性乘法下降

---

## 规则 28：冗余 vs 分工 — 软件工程不需要航天级冗余

**误区**: "让两个 AI 做同一件事取共识"能提高可靠性。

**现实**: 只有航天/核电等人命关天的场景才用冗余。软件开发用的是**分工 + 信息交流**:
- A 写代码，B 审代码（不是 B 也写一份）
- B 用不同视角（全局设计、业务逻辑）审 A 的产出

**Agent Swarm 为什么不靠谱**:
- 每个 Agent 都是概率性的（ARCH-06）
- Agent 间的通信用自然语言，又多一层理解偏差
- 协调开销 > 分工收益

---

## 当前系统的最优防线

| 层级 | 手段 | 确定性 | 负责什么 |
|------|------|--------|---------|
| L1 | 编译器/lint/类型检查 | ✅ 100% | 语法、格式 |
| L2 | AI 自检 (role-SECA Section 3) | ⚠️ 有盲区 | 逻辑、结构 |
| L3 | 用户 review | ✅ 异构视角 | 意图、常识 |
| L4 | 跨 session 复查 | ✅ 视角刷新 | 全局设计 |

---

## 规则 29：异构模型 Review — Manager-Worker 模式（修正）

**之前的错误观点**: "多 Agent 不该做"——过于绝对。

**修正后的观点**: 不同模型 review 不同方面 + 一个强模型整合 = 有效的工业实践。

**工业界验证**:
- Uber uReview: 多阶段 AI 架构拆分 review 子任务 `[已验证, 2025]`
- Mixture-of-Agents (MoA): 开源模型组合超过单个大模型 `[论文验证]`
- "Judge" 模式: 强模型评估弱模型的输出 `[行业实践]`

**正确架构**: Manager-Worker（并联 + 聚合），不是串联：

```
Worker A (逻辑) ──┐
Worker B (安全) ──┼──→ Manager (整合判断) ──→ 人类最终确认
Worker C (可读) ──┘
```

**与 ARCH-06 的关系**: 不矛盾。ARCH-06 说的是串联导致可靠性下降；
并联 + 聚合是不同模式——Worker 独立、Manager 综合、人类兜底。

**渐进实施路径**:
- Phase 1（当前）: 单 Agent + 确定性工具 + 人类审查
- Phase 2（近期）: 手动把代码粘给另一个模型二次意见
- Phase 3（未来）: 自动化 Manager-Worker Pipeline，需 API 调用多模型

**适用场景**: 高风险代码、架构设计决策。日常修改不需要。

**防止 Manager 过载的关键设计**: Worker 的职责是**压缩**，不是扩展：

```
500行代码 ──→ Worker A ──→ 10行结构化报告 ──┐
             Worker B ──→ 10行结构化报告 ──┼→ Manager（只读报告，不读代码）→ 优先级清单 → 人类决策
             Worker C ──→ 10行结构化报告 ──┘                                              │
                                                                                           ▼
                                                                                修改 Agent（新 session）
```

- Worker 输出结构化清单（JSON/表格），不是自然语言长文
- Manager 只合并报告、标记 Worker 间的矛盾、按严重程度排序
- Manager **不读原始代码**，不做修改 — 修改在独立 session 中进行
- 类比：CTO 读报告，不读代码

**⚠️ 风险与代价**:
- Token 成本：每增加一个 Worker = 额外的 API 调用费用，日常代码不值得
- 结构复杂性：多模型管道本身增加了系统的不确定性和不可读性
- 调试困难：出错时难以定位是哪个 Worker / Manager 的问题
- **KISS 原则的警告**：如果这个系统的复杂度已经让你无法一眼看懂流程，那它可能太复杂了
