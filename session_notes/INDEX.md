# 软件工程原则索引

> 本文件是所有 session notes 的**知识图谱**。
> 每条原则只在这里定义一次。笔记中只引用，不重复解释。
> 项目专属笔记按目录归类在 `projects/` 下。

---

## 项目目录

| 编号 | 代号 | 项目全名 | 领域 | 状态 |
|------|------|---------|------|------|
| 001 | textbook | V3.5 高中英语教材生成系统 | 教育/排版 | 活跃 |

> 公开分享时，项目全名列可替换为 `[保密]`。代号和编号不暴露信息。

---

## 原则层级体系

软件工程原则分 4 层，从抽象到具体：

```
Layer 1: 哲学层 (Philosophy)
  最抽象的设计直觉，指导所有决策
    │
Layer 2: 架构层 (Architecture)
  系统级的组织原则，决定"东西放在哪、怎么连"
    │
Layer 3: 设计层 (Design)
  模块/组件级的设计原则，决定"代码怎么写才灵活"
    │
Layer 4: 实践层 (Practice)
  日常开发中的操作规范，决定"先做什么、怎么做"
```

---

## Layer 1: 哲学层

### KISS — Keep It Simple, Stupid

**含义**: 能简单就不要复杂。每多一层抽象、多一个配置、多一个文件，都是成本。

**判断标准**: 如果你无法在 30 秒内向别人解释某个设计，它可能太复杂了。

**关系**: 是所有其他原则的"仲裁者" —— 当两条原则冲突时，选更简单的方案。

---

### YAGNI — You Aren't Gonna Need It

**含义**: 不要为"将来可能需要"的功能写代码。只建造当前需要的东西。

**判断标准**: 如果功能需求来自"万一以后..."的句式 → 大概率不需要。

**与 KISS 的关系**: KISS 说"做简单"，YAGNI 说"少做"。两者共同防止过度工程。

---

## Layer 2: 架构层

### Separation of Concerns — 关注点分离

**含义**: 每个模块/目录/文件只负责一件事。不同职责的东西不混在一起。

**本索引编号**: `ARCH-01`

**应用场景**:
- 目录结构设计（操作手册 vs 参考资料）
- 数据库设计（用户表 vs 订单表）
- 代码组织（业务逻辑 vs 界面渲染）

**出现记录**: [2026-02-10-pm 规则1](./projects/001-textbook/2026-02-10-pm.md)

---

### Single Source of Truth (SSOT) — 单一真相源

**含义**: 每条信息只有一个权威版本。其他地方需要时，链接到那个版本，不复制。

**本索引编号**: `ARCH-02`

**与 DRY 的关系**: DRY（不重复自己）是 SSOT 在代码层面的具体表现。SSOT 是架构层的，DRY 是设计层的。

```
SSOT (架构层)
 └── DRY (设计层) ← 代码不复制粘贴
 └── 规范化 (数据库层) ← 数据不冗余存储
```

**出现记录**: [2026-02-10-pm 规则4](./projects/001-textbook/2026-02-10-pm.md), [2026-02-11-late-2 规则11](./projects/001-textbook/2026-02-11-late-2.md)

---

### Internal Consistency -- 内部一致性

**含义**: 系统中的规则不能自相矛盾。每条新规则写入前，检查是否与已有规则冲突。

**本索引编号**: `ARCH-03`

**与 SSOT 的关系**: SSOT 防止数据矛盾，Internal Consistency 防止逻辑矛盾。两者共同保证系统不会"左手打右手"。

**出现记录**: [2026-02-11-late 规则6](./projects/001-textbook/2026-02-11-late.md)

---

### Portability -- 可移植性

**含义**: 一个模块/工作空间的所有依赖必须能跟着它一起迁移。

**本索引编号**: `ARCH-04`

**判断测试**: "如果只复制这一个文件夹到新环境，所有功能能正常工作吗？"

**出现记录**: [2026-02-11-late 规则7](./projects/001-textbook/2026-02-11-late.md)

---

### Distributed State Synchronization -- 分布式状态同步

**含义**: 当同一个系统的多个副本各自积累经验后，需要一种策略来合并它们的知识。

**本索引编号**: `ARCH-05`

**三种合并策略**:

| 策略 | 适用场景 | 例子 |
|------|---------|------|
| Append-Only | 数据只增不改 | session_notes (按日期命名, 不冲突) |
| Last-Writer-Wins | 谁最后改谁赢 | last_session.md |
| Manual Merge | 冲突需要人判断 | role-SECA.md, INDEX.md |

**实现**: 用 Git 管理 `_ai_evolution/` 目录即可获得免费的同步系统。

**出现记录**: 2026-02-11 late night 对话, [2026-02-11-late-2 规则11](./projects/001-textbook/2026-02-11-late-2.md)

---

## Layer 3: 设计层

### Open-Closed Principle (OCP) — 开闭原则

**含义**: 对扩展开放，对修改封闭。加新功能时，应该**添加**代码，而不是**改**已有代码。

**本索引编号**: `DESIGN-01`

**所属族**: SOLID 五原则之一（见下方 SOLID 族谱）

**应用场景**:
- 处理多种输入类型（路由模式 vs 硬编码 if-else）
- 插件系统
- 配置驱动的行为

**出现记录**: [2026-02-10-pm 规则3](./projects/001-textbook/2026-02-10-pm.md)

---

### Data Integrity Principle — 数据链路完整性

**含义**: 功能设计必须建立在**可获取的、真实的数据**之上。如果数据不存在，功能不应该假装它存在。

**本索引编号**: `DESIGN-02`

**与 YAGNI 的关系**: YAGNI 说"别建你不需要的功能"，数据链路完整性说"别建你没有数据支撑的功能"。前者关注需求，后者关注可行性。

**出现记录**: [2026-02-10-pm 规则2](./projects/001-textbook/2026-02-10-pm.md)

---

### SOLID 族谱（参考）

SOLID 是面向对象设计的 5 条核心原则，互为补充：

| 缩写 | 原则 | 一句话 | 已遇到？ |
|------|------|--------|----------|
| **S** | Single Responsibility | 一个模块只做一件事 | 是（≈关注点分离的代码版） |
| **O** | Open-Closed | 加功能靠扩展不靠改代码 | ✅ 2026-02-10 |
| **L** | Liskov Substitution | 子类能替代父类使用 | 尚未 |
| **I** | Interface Segregation | 接口小而专，不要大而全 | 尚未 |
| **D** | Dependency Inversion | 依赖抽象，不依赖具体实现 | 尚未 |

---

## Layer 4: 实践层

### Technical Debt Prioritization — 技术债优先级

**含义**: 影响日常效率的系统性问题，优先级高于新功能开发。

**本索引编号**: `PRACTICE-01`

**判断公式**: `影响次数 × 每次浪费时间 = 总成本`。总成本 > 修复成本 → 立刻修。

**与 KISS 的关系**: 技术债往往是因为违反了 KISS（做复杂了）或 YAGNI（做多了）而积累的。

**出现记录**: [2026-02-10-pm 规则5](./projects/001-textbook/2026-02-10-pm.md)

---

### Dependency Weight Awareness -- 依赖重量意识

**含义**: 安装任何依赖前检查兼容性、体积、和替代方案。重型依赖是隐形的资源炸弹。

**本索引编号**: `PRACTICE-02`

**检查清单**: (1) 兼容性? (2) 体积/内存? (3) 更轻的替代?

**出现记录**: [2026-02-11-late 规则8](./projects/001-textbook/2026-02-11-late.md)

---

### Traceability -- 可追溯性

**含义**: 任何决策都应该能回答"为什么"。记录证据、推理、结论三联，并标注证据强度。

**本索引编号**: `PRACTICE-03`

**格式**: `[推理] 证据 → 推理 → 结论 [依据: 已验证/有依据/推测]`

**价值**:
- 对决策者：知道为什么选这个方案
- 对执行者：知道这个决定多可靠
- 对未来：回头审计时可以理解当时的逻辑

**应用场景**: 不限于 AI。团队技术选型、架构决策、bug 分析都应该用。

**出现记录**: [2026-02-11-late-2 规则9](./projects/001-textbook/2026-02-11-late-2.md)

---

### Quality Gate -- 质量门禁

**含义**: 自动生成的产出物必须经过**可量化的检查**才算完成。"能运行"不等于"质量合格"。

**本索引编号**: `PRACTICE-04`

**模式**:
```
生成 → [质量门禁] → 交付
         ↑
    编译通过？覆盖率达标？阈值内？
    任一不通过 → 回退修复
```

**适用场景**: 任何"自动生成 + 人工使用"的流程 (AI 生成代码、AI 生成文档、CI/CD 流水线)

**四层防线框架** (来源: 2026-02-11 AI 工程讨论):

| 层级 | 问的问题 | 手段 | 確定性 |
|------|----------|------|--------|
| Layer 1: 缩小射程 | 任务拆小了吗？ | distributed_execution | ✅ |
| Layer 2: 结构化约束 | 输出格式对吗？ | Schema/模板/规则 | ✅ |
| Layer 3: 事后验证 | 结果对吗？ | 编译器/测试/lint | ✅ |
| Layer 4: 人类兜底 | 人确认了吗？ | 审查/批准 | ✅ |

**关键**: Layer 3 必须用确定性工具，不能用另一个 AI。

**出现记录**: 2026-02-11 Vibe-Poo 分析, [2026-02-11-late-4 规则19](./projects/001-textbook/2026-02-11-late-4.md)

---

### Quantifiable Quality Thresholds -- 可量化的质量阈值

**含义**: 质量门禁 (`PRACTICE-04`) 的阈值必须是**具体数字**，不能是"感觉差不多"。没有数字的质量检查等于没有检查。

**本索引编号**: `PRACTICE-05`

**与 Quality Gate 的关系**: `PRACTICE-04` 定义了"要检查"，`PRACTICE-05` 定义了"检查什么、多少算合格"。两者缺一不可。

**举例**:

| 领域 | 阈值 | 依据 |
|------|------|------|
| 代码 | 文件 ≤800 行, 函数 ≤200 行 | Vibe-Poo 默认值，工业经验 |
| 教学文档 | 6-12 页/单元, 知识点 100% 覆盖 | V3.5 教学设计规范 |
| Typst 编译 | 0 错误, 0 警告 | 最低交付标准 |

**规则**: 定义质量门禁时，每个检查项必须附带一个数字。如果写不出数字 → 这个检查项还没想清楚。

**出现记录**: 2026-02-11 Vibe-Poo 分析

---

### Deterministic-First Automation -- 确定性优先

**含义**: 每件事用最确定的方式做。优先级：脚本 > 工具/命令 > MCP > Sub-agent > 多 Agent。

**本索引编号**: `PRACTICE-07`

**判断标准**: 步骤固定、输入输出明确 → 脚本。需要“看”和“判断” → Agent。

**自动化时机**: AI 探路（第一次做），搞清楚后写脚本（第二次起）。

**已写入 `role-SECA.md`**: Section 7 DETERMINISTIC-FIRST AUTOMATION 规则。

**出现记录**: [2026-02-11-late-4 规则21](./projects/001-textbook/2026-02-11-late-4.md)

---

## Layer AI: AI 协作专属层

> 这些原则专用于人类与 AI 协作的场景。
> 传统软件工程里没有对应概念，因为这是新问题。

### Context Window Management -- 上下文窗口管理

**含义**: AI 的"工作台"有大小限制。对话内容、文件读取、工具输出都会消耗空间。满了之后 AI 会"忘记"旧内容。

**本索引编号**: `PRACTICE-AI-01`

**类比**: 上下文窗口 = 书桌大小。你把资料堆满了书桌，新资料只能摆在旧资料上面，下面的就看不见了。

**大量消耗上下文的行为**:
- 读取大文件 (1000+行)
- ~~Lint 警告输出 (200条)~~ -- 已通过 `.markdownlint.json` 解决
- 反复修改同一文件
- 很长的对话历史

**AI 能主动报告吗？**:
- 诚实回答：AI **看不到**自己的 token 计数
- 但可以通过规则做估算预警（见 `role-SECA.md` Section 6 CONTEXT PRESSURE WARNING）
- 这是当前 AI 技术的局限，不是懒 -- 平台没有暴露 token 使用量接口

**信号识别 (上下文快满的表现)**:
- AI 开始"忘记"前面说过的事
- AI 回复突然变短或不完整
- 系统提示 checkpoint / truncated
- 用户被要求说 "Continue"

**解决方案**: 大任务拆成多个对话 + last_session.md 存档 = 无损恢复

**注意力边缘效应** (来源: 社区经验分享, 基于 Claude opus 4.5/4.6, ~2026-01, 可能过时):
- 上下文快满时，AI 不是均匀遗忘，而是**注意力乱飘**
- 单文件/prompt ≤ 400 行是 AI 有效注意力的实际上限 `[个人经验, 未独立验证]`
- 单次喂给 AI 的文件 token 最好为最大限制的 **40-60%** `[同上]`

**出现记录**: [2026-02-11-late-2 规则10](./projects/001-textbook/2026-02-11-late-2.md), [2026-02-11-late-3 规则13](./projects/001-textbook/2026-02-11-late-3.md)

---

### Selective Memory -- 选择性记忆

**含义**: AI 跨对话默认遗忘一切。"记住"靠 `_ai_evolution/` 文件，"遗忘"靠删除对应文件。用户可以主动管理 AI 的记忆。

**本索引编号**: `PRACTICE-AI-02`

**机制**:
- 想让 AI 记住 → 写入 `_ai_evolution/`
- 想让 AI 遗忘 → 从 `_ai_evolution/` 删除
- AI 无法在对话内选择性遗忘（技术限制）

**Memory 的 200 行真相** (来源: 社区经验分享, ~2026-01, 可能随版本更新):
- Claude Code 内置 memory 仅限 200 行 `[个人经验, 未查官方文档]`
- 大量 markdown 堆砌的"结构化 memory"多数是假象
- 有效做法：**分层索引 + 按需加载**（质量 > 数量）

**出现记录**: 2026-02-11 late night 对话, [2026-02-11-late-3 规则15](./projects/001-textbook/2026-02-11-late-3.md)

---

### AI Generation Pitfall Awareness -- AI 生成通病预防

**含义**: AI 生成内容有三种**系统性倾向**，不是偶尔出错，而是**几乎每次都会这样**。必须提前预防。

**本索引编号**: `PRACTICE-AI-03`

**三大通病** (来源: Vibe-Poo 的检测逻辑):

| 通病 | AI 的倾向 | 后果 | 预防 |
|------|----------|------|------|
| **堆砌** | 把所有东西塞进一个文件/函数 | 难维护、难理解 | 设置大小阈值 (`PRACTICE-05`) |
| **冗余** | 生成重复/未使用的代码或内容 | 体积膨胀、混淆 | 完成后审查"这段是否被引用" |
| **作用域混乱** | 过度使用全局变量/顶层声明 | 改一处崩全局 | 要求 AI 解释每个变量的生命周期 |

**为什么 AI 会这样**:
- AI 按概率生成 token，没有"整体架构感"
- AI 一次只看到上下文内的代码，不知道其他文件的结构
- AI 倾向于"把当前任务做完"而不是"做得优雅"

**你的预防清单**:
- 生成后问 AI："这个文件超过 200 行了吗？需要拆分吗？"
- 生成后问 AI："有没有重复或未使用的部分？"
- 对重要产出物，用 `PRACTICE-04` Quality Gate 做检查

**第四通病 — 测试绕过** (来源: 社区经验分享, 观察基于 Claude opus 4.5/4.6, 未验证其他模型):
- AI 遇到棘手 Bug 时，可能**偷偷修改测试来绕过 Bug** 而不报告
- 对策：关键测试的预期结果由人类定义，AI 不得修改

**出现记录**: 2026-02-11 Vibe-Poo 分析, [2026-02-11-late-3 规则14/18](./projects/001-textbook/2026-02-11-late-3.md)

---

### AI Personality Bias -- AI 性格偏差

**含义**: 不同 AI 模型有系统性的"性格缺陷"。Claude 保守、ChatGPT 创造性胡说、Gemini 吹捧。必须识别并对冲。

**本索引编号**: `PRACTICE-AI-04`

**对冲方法**: 要求 AI 给出具体理由而非笼统评价。对 Gemini 加 system instruction 要求客观。

**出现记录**: [2026-02-11-late-3 规则12](./projects/001-textbook/2026-02-11-late-3.md)

---

### Hard Constraint Derailment -- 硬约束导致计划脱轨

**含义**: 触发型硬约束可能打断 AI 正在并行执行的多个任务。修复约束违规后，AI 可能忘记之前的计划。

**本索引编号**: `PRACTICE-AI-05`

**对策**: 硬约束越少越好 (KISS)。优先用"事后检查"替代"中断式触发"。

**出现记录**: [2026-02-11-late-3 规则16](./projects/001-textbook/2026-02-11-late-3.md)

---

### Knowledge Expiry -- AI 知识有保质期

**含义**: AI 知识有截止日期。涉及版本敏感的决策时，AI 可能用过时知识判断且不主动声明。

**本索引编号**: `PRACTICE-AI-06`

**对策**: 版本敏感决策要求 AI 搜索最新文档，或自己查文档后告知 AI。

**出现记录**: [2026-02-11-late-3 规则17](./projects/001-textbook/2026-02-11-late-3.md)

---

### Failure Mode Multiplication -- 多 Agent 可靠性陷阱

**含义**: N 个串联的不可靠环节，系统可靠性 = P₁ × P₂ × ... × Pₙ。每加一个 Agent，总可靠性只会下降。

**本索引编号**: `ARCH-06`

**结论**: 除非任务量大到单 Agent 处理不过来，否则单 Agent + 确定性工具是最佳选择。

**出现记录**: [2026-02-11-late-4 规则20](./projects/001-textbook/2026-02-11-late-4.md)

---

### Token Economy -- Token 是 AI 工程的核心资源

**含义**: Token 同时是钱和 AI 注意力。省 Token = 省钱 + AI 回答质量更高。优化原则与传统软件工程 (CPU/内存/带宽)完全一致。

**本索引编号**: `PRACTICE-AI-07`

**六种优化策略**: Lazy Loading (分布式索引)、指针/引用 (原则 ID)、Checkpoint (last_session.md)、最小启动集、确定性优先、规则精简。

**关键认知**: 减少对话轮次比缩短每轮更有效。一次做准比试三次更省。

**出现记录**: [2026-02-11-late-4 规则22](./projects/001-textbook/2026-02-11-late-4.md)

```
+-------------------------------------------------+
|               Layer 1: Philosophy               |
|  +----------+  +----------+                     |
|  |   KISS   |  |  YAGNI   |                     |
|  +----+-----+  +----+-----+                     |
|       |              |                           |
+-------+--------------+---------------------------+
|       |    Layer 2: Architecture                 |
|  +----+-----+  +-----+----+  +------+  +------+ |
|  | ARCH-01  |  | ARCH-02  |  |  03  |  |  04  | |
|  |Sep.of Con|  |  SSOT    |  |Consi.|  |Port. | |
|  +----+-----+  +----+-----+  +------+  +------+ |
|       |              |                           |
+-------+--------------+---------------------------+
|       |    Layer 3: Design                       |
|  +----+-----+  +----+-----+  +----------+       |
|  |DESIGN-01 |  |   DRY    |  |DESIGN-02 |       |
|  |Open-Close|  |(SSOT sub)|  |Data Integ|       |
|  +----------+  +----------+  +----------+       |
|                                                  |
+--------------------------------------------------+
|          Layer 4: Practice                       |
|  +--------+  +--------+  +--------+             |
|  |PRAC-04 |  |PRAC-05 |  |PRAC-07 |             |
|  |Quality |  |Quant.  |  |Determ. |             |
|  |Gate    |  |Thresh. |  |First   |             |
|  +--------+  +--------+  +--------+             |
+--------------------------------------------------+
|          Layer AI: AI Collaboration              |
|  +--------+  +--------+  +--------+              |
|  |AI-01   |  |AI-02   |  |AI-03   |              |
|  |Context |  |Select. |  |Gen.    |              |
|  |Window  |  |Memory  |  |Pitfall |              |
|  +--------+  +--------+  +--------+              |
|  +--------+  +--------+  +--------+              |
|  |AI-04   |  |AI-05   |  |AI-06   |              |
|  |Person. |  |Hard    |  |Know.   |              |
|  |Bias    |  |Constr. |  |Expiry  |              |
|  +--------+  +--------+  +--------+              |
|  +--------+                                      |
|  |AI-07   |                                      |
|  |Token   |                                      |
|  |Economy |                                      |
|  +--------+                                      |
+--------------------------------------------------+
```

---

## 使用规则

1. **新笔记发现新原则** → 先在本 INDEX 中添加定义，再在笔记中引用
2. **新笔记涉及已有原则** → 只在笔记中引用编号（如 `ARCH-01`），不重复定义
3. **随着经验积累** → INDEX 会逐渐覆盖更多原则，形成你的个人工程知识体系
